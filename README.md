# 以函数库的形式提供IAP更新功能

## 简介:
本工程通过散列加载文件指定链接地址,并拷贝相关代码到ram中运行,实现通过串口1更新内部flash数据的功能,协议帧格式参考正点原子[XCOM](https://amobbs.com/thread-5703833-1-1.html)    
串口助手

## 编写原因:
经典IAP的实现方式是创建两个独立的工程,并且将内部flash分区存放IAP程序和APP程序,上电后通过IAP程序加载APP.此工程以函数调用的方式提  
供IAP功能,可以以本工程为模板编写自己的程序,无需关心IAP程序和APP程序如何组织,只需要在适当的位置调用几个函数即可进入IAP模式更新固  
件.
## 使用简介:
- 调用`ZI_and_RW_init()`函数为主程序初始化ZI段
- 调用相关函数拷贝代码以及`VectorTable[]`到ram中对应位置,设置中断向量表到ram起始位置,设置栈顶到内存地址最高处
- 调用`iap_ram_app()`函数
- 打开XCOM串口助手切换到协议传输功能,**设置最大数据长度为128**
- 打开要传输的bin文件点击发送
- 默认下载到flash起始地址,即`0x08000000`
## 其他:
此工程编写于STM32F103C8T6其他型号需要修改启动文件以及`VectorTable[]`数组以及和内存、FLASH大小相关的宏定义,其他单片机需要重新实   
现`iapram.c`中的收发函数以及`bridge.c`中的大部分函数 

## 开发日记
 - 20221205 实现基本更新功能
   - TODO:    
      抽象收发函数等为接口函数的形式方便移植  
      创建函数列表实现更新部分flash以及通过串口调用内部函数   
      编写上位机 

 - 20221207 取消了sct文件中ER_VECTOR并且指定RW ZI 段的OVERLAY属性减少内存开销 
   - TODO:  
      抽象收发函数等为接口函数的形式方便移植  
      创建函数列表实现更新部分flash以及通过串口调用内部函数   
      编写上位机  
      ~~由于KEIL的armlink将一个执行域指定为OVERLAY后不会被c库初始化所以暂时没有办法实现去除ram_app在链接过程中的ram占用,理想状   
      态是 在ram_app中使用自定义的malloc函数分配变量内存从而使原工程文件可以使用100%的内存空间,即编译ram_app后不产生rw和zi段~~